# my-haskell-learning

Haskell の勉強記録.
GHC のバージョンは, stack ghc 8.6.5 です.
stack ghci とかで実行できます.

```
stack ghci
```

```
:l example.hs
```

## crypt.hs

Haskell を用いて rot, xor 線形合同法などを実装

## direct_sum.hs

直和型の例として, お店で売られている商品について実装.

### 直和型

直和型とは, Haskell における他の型と OR で組み合わせることによって作成される型
具体例を見せると分かりやすいと思うので,

```
data Name = Name FirstName LastName | NameWithMiddle FirstName MiddleName LastName
```

Name 型は, メンバに FirstName と LastName を持っている場合と, FirstName と LastName, さらに MiddleName を持っている場合の両方を許容するという意味である.

直積型のみを用いた実装でよくある階層的設計とおさらばできるらしい(オブジェクト指向の継承的なもの)

## semigroup.hs monoid.hs について

半群とモノイドについて実装しました.
以下用語の説明です.

### Compose

「.」という演算子を用いて, 関数を合成する.
やっていることとしては,

```
f . g = (\x -> f (g x))
```

例として, 配列の最後の値を取る関数

```
myLast :: [a] -> a
myLast = head . reverse
```

### Magma(マグマ)

足し算あるいは掛け算ができる構造.

例えば, Integer 型では,

```
instance Magma Integer where
 (<>) :: (+)
```

こうとも書ける.

```
instance Magma Integer where
 (<>) x y = x + y
```

ちなみに, この場合の型シグニチャは,

```
(<>) :: a -> a -> a
```

このとき, (<>)は a に閉じている(<>で演算しても, 型は a のまま).

### 半群(Semigroup)

マグマ + 演算が結合律に従う構造(左右どちらから演算しても変わらない).

例として, <>という演算子について,

```
x <> (y <> z) == (x <> y) <> z
```

が成立する.

### モノイド(Monoid)

単位元を要求する Semigroup といった印象.
単位元とある値 x を演算しても, x となる.

```
e <> x == x <> e == x
```

```
class Monoid a where
 mempty :: a
 mappend :: a -> a -> a
 mconcat :: [a] -> a
```

## maybe.hs

Maybe 型についての実装

Maybe 型とは: 欠損するかもしれない値をコンテキストで表すことができる型

他の言語のような null 値に対するエラーで悩まされることから解放されるらしい...?

Maybe 型を使えば, 例外が生じたとき, とりあえず値を Nothing にして次に進めるのがいい. map とかの作業途中に, エラーをキャッチしたせいで処理が終了するといったことがない.

### 二分探索木(binary_index_tree.hs)

#### (1) select 関数

引数に Int 型の List をとって, 要素に Int と Int の List を持つタプルの List を返す. List の中の一つの値を取って, その値と, その値を除いた残りの List を組み合わせたタプルの配列を返す. 具体的には,

```
select [1,2,3,4,5,6]
```

と実行すると,

```
[(1,[2,3,4,5,6]),(2,[1,3,4,5,6]),(3,[1,2,4,5,6]),(4,[1,2,3,5,6]),(5,[1,2,3,4,6]),(6,[1,2,3,4,5])]
```

と返す.

#### (2) permutation 関数

Int 型の List を引数にとって, Int 型の List の List を返す. [1,2,3,..,n]という List が渡されたら, その List の数字を用いて作れるすべての組み合わせの List を返す. permutation 関数の実行例は課題 1 の実行例を参照.

#### (3) makePermutationFromInt 関数

Int 型の値を引数にとって, Int 型の List の List を返す. 例えば, n が引数として与えられると, [1,2,3,..,n]という List の数字を用いて作れるすべての組み合わせの List を返す. makePermutationFromInt 関数の実行例は課題 2 の実行例を参照.

#### (4) Tree 型について

Tree 型という新しい型を作成した. Tree 型は, 子が存在しないことを表す Empty, または Node のどちらかを許可する. Node には Int 型の要素と, Tree 型である左の子, 右の子を持つ. また Tree 型を定めるにあたって演算子(==)を再定義した. 2 つの木を親からたどっていってすべての頂点を見た結果, 同形の木であるのならば, 等しい, そうでないのなら, 等しくない, ということにした.

#### (5) treeElem 関数

Int 型の要素が木に入っているかどうかを判別する. 木の中にその数字が含まれる場合, True, 含まれない場合, False を返す. 親からたどってって親の数字が, 探したい数字よりも大きければ左の子を調べ, 小さければ右の子を調べる. 探したい数字が Node に存在するまで, 再帰的に調べる.

#### (6) getHeight 関数

木の高さを求める. 引数に Tree 型を引数にとって, Int 型を返す. 左の子の高さと右の子の高さの大きい方に自分の高さ分+1 を足す. これも再帰的に木の下へとたどる.

#### (7) insert 関数

木に数字を挿入する. 元々木にその数字が含まれている場合は何もしない. 挿入したい数字が現在の頂点の数字より小さい場合は, 現在の頂点の右の子を見る. 大きい場合は, 現在の頂点の左の子を見る. 子が Empty の場合は, その Empty の位置に数字を挿入して新しい頂点を作る.

#### (8) makeBSTfromPermutation 関数

引数に Int 型をとって, Tree 型の List を返す. ある数字 n を元に, [1,2,..,n]を用いて表されるすべての順列を作り, その順列の順序を元に二分探索木を作成する.

#### (9) numBST 関数

引数に Tree 型の List をとって, 生成された二分探索木の個数(Int 型)を返す.

#### (10) sumHeightBST 関数

引数に Tree 型の List をとって, List の中のすべての二分探索木の高さの合計(Int 型)を返す.

#### (11) averageHeightBST 関数

引数に Tree 型の List をとって, List の中のすべての二分探索木の高さの平均(Float 型)を返す. sumHeightBST 関数で求めた値を, numBST 関数で求めた値で割ることで平均が出てくる.

#### (12) varianceHeightBST 関数

引数に Tree 型の List をとって, List の中のすべての二分探索木の高さの分散(Float 型)を返す. それぞれの木の高さから平均を引いて 2 乗した値の合計を, 二分探索木の個数で割って求める.

#### (13) uniqueBST 関数

生成された二分探索木の中で, 相異なる二分探索木の List を返す.その木がその木を除いた木の List に含まれる場合, その木を削除することを List の左から再帰的に繰り返す.

#### (14) diffLessThan2 関数

ある親の左の子と右の子の高さが 1 以下ならば, True, 2 以上ならば, False を返す関数である.

#### (15) isAVL 関数

与えられた木が, AVL 木かどうか判別する. 木の親から順に, 2 つの子の高さの差が 1 以下かどうかを再帰的に判別する.

#### (16) avlTrees 関数

Tree 型の List の中から, AVL 木のみを抽出して, Tree 型の List を返す.

### 実行例

#### 二分探索木作成の例

```
tree = foldl insert Empty [5,3,7,1,9]
```

```
       5
      3 7
     1   9
```

みたいな木ができる.

#### (1) 1..n までの自然数から出来る順列をすべて発生させる.

##### 実行例 1

```
permutation [1..3]
```

##### 実行例 2

```
makePermutationFromInt 3
```

実行結果(実行例 1,2 ともに同じ)

```
[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

##### 実行例 3

```
makePermutationFromInt 5
```

```
[[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1,3,2,4,5],[1,3,2,5,4],[1,3,4,2,5],[1,3,4,5,2],[1,3,5,2,4],[1,3,5,4,2],[1,4,2,3,5],[1,4,2,5,3],[1,4,3,2,5],[1,4,3,5,2],[1,4,5,2,3],[1,4,5,3,2],[1,5,2,3,4],[1,5,2,4,3],[1,5,3,2,4],[1,5,3,4,2],[1,5,4,2,3],[1,5,4,3,2],[2,1,3,4,5],[2,1,3,5,4],[2,1,4,3,5],[2,1,4,5,3],[2,1,5,3,4],[2,1,5,4,3],[2,3,1,4,5],[2,3,1,5,4],[2,3,4,1,5],[2,3,4,5,1],[2,3,5,1,4],[2,3,5,4,1],[2,4,1,3,5],[2,4,1,5,3],[2,4,3,1,5],[2,4,3,5,1],[2,4,5,1,3],[2,4,5,3,1],[2,5,1,3,4],[2,5,1,4,3],[2,5,3,1,4],[2,5,3,4,1],[2,5,4,1,3],[2,5,4,3,1],[3,1,2,4,5],[3,1,2,5,4],[3,1,4,2,5],[3,1,4,5,2],[3,1,5,2,4],[3,1,5,4,2],[3,2,1,4,5],[3,2,1,5,4],[3,2,4,1,5],[3,2,4,5,1],[3,2,5,1,4],[3,2,5,4,1],[3,4,1,2,5],[3,4,1,5,2],[3,4,2,1,5],[3,4,2,5,1],[3,4,5,1,2],[3,4,5,2,1],[3,5,1,2,4],[3,5,1,4,2],[3,5,2,1,4],[3,5,2,4,1],[3,5,4,1,2],[3,5,4,2,1],[4,1,2,3,5],[4,1,2,5,3],[4,1,3,2,5],[4,1,3,5,2],[4,1,5,2,3],[4,1,5,3,2],[4,2,1,3,5],[4,2,1,5,3],[4,2,3,1,5],[4,2,3,5,1],[4,2,5,1,3],[4,2,5,3,1],[4,3,1,2,5],[4,3,1,5,2],[4,3,2,1,5],[4,3,2,5,1],[4,3,5,1,2],[4,3,5,2,1],[4,5,1,2,3],[4,5,1,3,2],[4,5,2,1,3],[4,5,2,3,1],[4,5,3,1,2],[4,5,3,2,1],[5,1,2,3,4],[5,1,2,4,3],[5,1,3,2,4],[5,1,3,4,2],[5,1,4,2,3],[5,1,4,3,2],[5,2,1,3,4],[5,2,1,4,3],[5,2,3,1,4],[5,2,3,4,1],[5,2,4,1,3],[5,2,4,3,1],[5,3,1,2,4],[5,3,1,4,2],[5,3,2,1,4],[5,3,2,4,1],[5,3,4,1,2],[5,3,4,2,1],[5,4,1,2,3],[5,4,1,3,2],[5,4,2,1,3],[5,4,2,3,1],[5,4,3,1,2],[5,4,3,2,1]]
```

#### (2) 二分探索木の個数

##### 実行例 1

```
numBST $ makeBSTfromPermutation 5
```

```
120
```

##### 実行例 2

```
numBST $ makeBSTfromPermutation 7
```

```
5040
```

#### (3) 二分探索木の高さの平均

##### 実行例 1

```
averageHeightBST $ makeBSTfromPermutation 5
```

```
3.8
```

##### 実行例 2

```
averageHeightBST $ makeBSTfromPermutation 7
```

```
4.66984126984127
```

#### (4) 二分探索木の高さの分散

##### 実行例 1

```
varianceHeightBST $ makeBSTfromPermutation 5
```

```
0.4266666666666666
```

##### 実行例 2

```
varianceHeightBST $ makeBSTfromPermutation 7
```

```
0.5703602922650577
```

#### (5) 相異なる二分探索木の個数

##### 実行例 1

```
numBST $ uniqueBST $ makeBSTfromPermutation 5
```

```
42
```

##### 実行例 2

```
numBST $ uniqueBST $ makeBSTfromPermutation 7
```

```
429
```

#### (6) 相異なる二分探索木の高さの平均

##### 実行例 1

```
averageHeightBST $ uniqueBST $ makeBSTfromPermutation 5
```

```
4.238095238095238
```

##### 実行例 2

```
averageHeightBST $ uniqueBST $ makeBSTfromPermutation 7
```

```
5.470862470862471
```

#### (7) 相異なる二分探索木高さの分散

##### 実行例 1

```
varianceHeightBST $ uniqueBST $ makeBSTfromPermutation 5
```

```
0.4671201814058956
```

##### 実行例 2

```
varianceHeightBST $ uniqueBST $ makeBSTfromPermutation 7
```

```
0.8785216337663938
```

#### (8) AVL 木の個数

##### 実行例 1

```
numBST $ avlTrees $ makeBSTfromPermutation 5
```

```
6
```

##### 実行例 2

```
numBST $ avlTrees $ makeBSTfromPermutation 7
```

```
17
```

#### (9) AVL 木の高さの平均

##### 実行例 1

```
averageHeightBST $ avlTrees $ makeBSTfromPermutation 5
```

```
3.0
```

##### 実行例 2

```
averageHeightBST $ avlTrees $ makeBSTfromPermutation 7
```

```
3.9411764705882355
```

#### (10) AVL 木の高さの分散

##### 実行例 1

```
varianceHeightBST $ avlTrees $ makeBSTfromPermutation 5
```

```
0.0
```

##### 実行例 2

```
varianceHeightBST $ avlTrees $ makeBSTfromPermutation 7
```

```
5.536332179930794e-2
```
